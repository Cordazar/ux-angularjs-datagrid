<!DOCTYPE html>

<html>
<head>
  <title>ux-datagrid-focusManager.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="ux-datagrid-disableHoverWhileScrolling.html">
                ux-datagrid-disableHoverWhileScrolling.js
              </a>
            
              
              <a class="source" href="ux-datagrid-focusManager.html">
                ux-datagrid-focusManager.js
              </a>
            
              
              <a class="source" href="ux-datagrid-iosScroll.html">
                ux-datagrid-iosScroll.js
              </a>
            
              
              <a class="source" href="ux-datagrid-expandRows.html">
                ux-datagrid-expandRows.js
              </a>
            
              
              <a class="source" href="ux-datagrid-findInList.html">
                ux-datagrid-findInList.js
              </a>
            
              
              <a class="source" href="ux-datagrid-gridLogger.html">
                ux-datagrid-gridLogger.js
              </a>
            
              
              <a class="source" href="ux-datagrid-infiniteScroll.html">
                ux-datagrid-infiniteScroll.js
              </a>
            
              
              <a class="source" href="ux-datagrid-scrollHistory.html">
                ux-datagrid-scrollHistory.js
              </a>
            
              
              <a class="source" href="ux-datagrid-sortModel.html">
                ux-datagrid-sortModel.js
              </a>
            
              
              <a class="source" href="ux-datagrid-statsModel.html">
                ux-datagrid-statsModel.js
              </a>
            
              
              <a class="source" href="ux-datagrid-windowScroll.html">
                ux-datagrid-windowScroll.js
              </a>
            
              
              <a class="source" href="angular-ux-datagrid.html">
                angular-ux-datagrid.js
              </a>
            
              
              <a class="source" href="ux-doubleScroll.html">
                ux-doubleScroll.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>ux-datagrid-focusManager.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/*
* uxDatagrid v.0.2.0
* (c) 2014, WebUX
* https://github.com/webux/ux-angularjs-datagrid
* License: MIT.
*/</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(exports, global)</span>{</span>
<span class="hljs-comment">/*global exports */</span>
<span class="hljs-comment">/**
 * Author: Jason Farrell
 * Author URI: http://useallfive.com/
 *
 * Description: Handles all things involving element visibility.
 * Package URL: https://github.com/UseAllFive/ua5-js-utils
 */</span>
exports.visibility = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-comment">/**
     * Checks if a DOM element is visible. Takes into
     * consideration its parents and overflow.
     *
     * @param (el)      the DOM element to check if is visible
     *
     * These params are optional that are sent in recursively,
     * you typically won't use these:
     *
     * @param (t)       Top corner position number
     * @param (r)       Right corner position number
     * @param (b)       Bottom corner position number
     * @param (l)       Left corner position number
     * @param (w)       Element width number
     * @param (h)       Element height number
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isVisible</span><span class="hljs-params">(el, t, r, b, l, w, h)</span> {</span>
        <span class="hljs-keyword">var</span> p = el.parentNode, VISIBLE_PADDING = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (!_elementInDocument(el)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>-- Return true for document node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-number">9</span> === p.nodeType) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>-- Return false if our element is invisible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-string">"0"</span> === _getStyle(el, <span class="hljs-string">"opacity"</span>) || <span class="hljs-string">"none"</span> === _getStyle(el, <span class="hljs-string">"display"</span>) || <span class="hljs-string">"hidden"</span> === _getStyle(el, <span class="hljs-string">"visibility"</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>-- If we have a parent, let&#39;s continue:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (p) {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>-- Let&#39;s recursively check upwards:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> _isVisible(p, t, r, b, l, w, h);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>-- Cross browser method to get style properties:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getStyle</span><span class="hljs-params">(el, property)</span> {</span>
        <span class="hljs-keyword">if</span> (window.getComputedStyle) {
            <span class="hljs-keyword">return</span> document.defaultView.getComputedStyle(el, <span class="hljs-literal">null</span>)[property];
        }
        <span class="hljs-keyword">if</span> (el.currentStyle) {
            <span class="hljs-keyword">return</span> el.currentStyle[property];
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_elementInDocument</span><span class="hljs-params">(element)</span> {</span>
        <span class="hljs-keyword">while</span> (element = element.parentNode) {
            <span class="hljs-keyword">if</span> (element == document) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> {
        getStyle: _getStyle,
        isVisible: _isVisible
    };
}();

<span class="hljs-comment">/*global exports */</span>
exports.selector = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> $ = $ || angular.element;
    <span class="hljs-comment">/**
     * build the string selector for the element.
     * @param {DomElement} element
     * @param {DomElement=} maxParent
     * @param {Function=} ignoreClass
     * @returns {string}
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelector</span><span class="hljs-params">(element, maxParent, ignoreClass)</span> {</span>
        <span class="hljs-keyword">var</span> selector = getSelectorData(element, maxParent, ignoreClass);
        <span class="hljs-keyword">return</span> selectorToString(selector) + <span class="hljs-string">":visible"</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelectorData</span><span class="hljs-params">(element, maxParent, ignoreClass)</span> {</span>
        <span class="hljs-keyword">if</span> (!element) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
        }
        maxParent = maxParent || document;
        <span class="hljs-keyword">return</span> {
            element: element,
            ignoreClass: ignoreClass,
            maxParent: maxParent,
            classes: getClasses(element, ignoreClass),
            type: element.nodeName.toLowerCase(),
            parent: getParentSelector(element, maxParent, ignoreClass)
        };
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getClasses</span><span class="hljs-params">(element, ignoreClass)</span> {</span>
        <span class="hljs-keyword">return</span> ux.filter(element.classList, ignoreClass);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectorToString</span><span class="hljs-params">(selector, depth)</span> {</span>
        <span class="hljs-keyword">var</span> matches, str;
        depth = depth || <span class="hljs-number">0</span>;
        str = selector ? selectorToString(selector.parent, depth + <span class="hljs-number">1</span>) : <span class="hljs-string">""</span>;
        <span class="hljs-keyword">if</span> (selector) {
            str += (str.length ? <span class="hljs-string">" "</span> : <span class="hljs-string">""</span>) + selector.type + (selector.classes.length ? <span class="hljs-string">"."</span> + selector.classes.join(<span class="hljs-string">"."</span>) : <span class="hljs-string">""</span>);
        }
        <span class="hljs-keyword">if</span> (!depth) {
            matches = selector.maxParent.querySelectorAll(str);
            <span class="hljs-keyword">if</span> (matches.length &gt; <span class="hljs-number">1</span>) {
                str += <span class="hljs-string">":eq("</span> + getIndexOfTarget(matches, selector.element) + <span class="hljs-string">")"</span>;
            }
        }
        <span class="hljs-keyword">return</span> str;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParentSelector</span><span class="hljs-params">(element, maxParent, ignoreClass)</span> {</span>
        <span class="hljs-keyword">var</span> parent = element.parentNode;
        <span class="hljs-keyword">if</span> (parent &amp;&amp; parent !== maxParent) {
            <span class="hljs-keyword">return</span> getSelectorData(element.parentNode, maxParent, ignoreClass);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIndexOfTarget</span><span class="hljs-params">(list, element)</span> {</span>
        <span class="hljs-keyword">var</span> i, iLen = list.length;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; iLen; i += <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (element === list[i]) {
                <span class="hljs-keyword">return</span> i;
            }
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> {
        getSelector: getSelector
    };
}();

exports.datagrid.events.FOCUS_TO_PREV_ELEMENT_OF_SAME = <span class="hljs-string">"ux-datagrid:focusToPrevElementOfSame"</span>;

exports.datagrid.events.FOCUS_TO_NEXT_ELEMENT_OF_SAME = <span class="hljs-string">"ux-datagrid:focusToNextElementOfSame"</span>;

<span class="hljs-comment">/**
 * Handle focus for enterKey to move down the correct columns.
 */</span>
angular.module(<span class="hljs-string">"ux"</span>).factory(<span class="hljs-string">"gridFocusManager"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(exp)</span> {</span>
        <span class="hljs-comment">/**
         * We want to add and remove listeners only on the dom that is currently under watch.
         */</span>
        <span class="hljs-keyword">var</span> result = {}, unwatchers = [];
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span><span class="hljs-params">(el)</span> {</span>
            <span class="hljs-keyword">if</span> (el.length === <span class="hljs-literal">undefined</span>) {
                el = angular.element(el);
            }
            <span class="hljs-keyword">return</span> el;
        }
        <span class="hljs-comment">/**
         * Add all of the listeners to the visible rows.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addListeners</span><span class="hljs-params">()</span> {</span>
            applyToListeners(addListenersToRow);
        }
        <span class="hljs-comment">/**
         * remove all of the listeners from min to max.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeListeners</span><span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>this needs executed before the activeRange changes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            applyToListeners(removeListenersToRow);
        }
        <span class="hljs-comment">/**
         * using the exp.activeRange.min/max apply methods to those rows.
         * @param method
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyToListeners</span><span class="hljs-params">(method)</span> {</span>
            <span class="hljs-keyword">if</span> (!exp.values.activeRange.max) {
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">var</span> i = exp.values.activeRange.min, row;
            <span class="hljs-keyword">while</span> (i &lt;= exp.values.activeRange.max) {
                row = exp.getRowElm(i);
                method(row);
                i += <span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-comment">/**
         * Get all of the focusable elements within an element
         * @param el
         * @returns {Array}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFocusableElements</span><span class="hljs-params">(el)</span> {</span>
            <span class="hljs-keyword">var</span> focusable = [].slice.call(el[<span class="hljs-number">0</span>].querySelectorAll(<span class="hljs-string">"input,a,select"</span>));
            <span class="hljs-keyword">return</span> ux.filter(focusable, filterVisible);
        }
        <span class="hljs-comment">/**
         * Filter the elements in the selection to only get those that are visible.
         * @param item
         * @returns {*}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterVisible</span><span class="hljs-params">(item)</span> {</span>
            <span class="hljs-keyword">return</span> ux.visibility.isVisible(item);
        }
        <span class="hljs-comment">/**
         * Move up the dom to determine the row of an element.
         * @param el
         * @returns {*}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRowElmFromChildElm</span><span class="hljs-params">(el)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>keep moving up until the parent is a chunk.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> parent = el.parent();
            <span class="hljs-keyword">while</span> (parent &amp;&amp; !parent.hasClass(exp.options.chunkClass)) {
                el = parent;
                parent = el.parent();
            }
            <span class="hljs-keyword">return</span> el;
        }
        <span class="hljs-comment">/**
         * Similar to jquery find.
         * @param el
         * @param selector
         * @returns {element|*}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">query</span><span class="hljs-params">(el, selector)</span> {</span>
            <span class="hljs-keyword">var</span> filters = selector.split(<span class="hljs-string">":"</span>), sel = filters.shift(), result = [].slice.call((el[<span class="hljs-number">0</span>] || el).querySelectorAll(sel));
            <span class="hljs-keyword">while</span> (filters.length) {
                result = filterSelection(filters.shift(), result);
            }
            <span class="hljs-keyword">return</span> angular.element(result);
        }
        <span class="hljs-comment">/**
         * Apply filters to the selection array.
         * @param filterStr
         * @param elements
         * @returns {*}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterSelection</span><span class="hljs-params">(filterStr, elements)</span> {</span>
            <span class="hljs-keyword">if</span> (filterStr.substr(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) === <span class="hljs-string">"eq("</span>) {
                <span class="hljs-keyword">return</span> filterEq(filterStr, elements);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filterStr.substr(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>) === <span class="hljs-string">"visible"</span>) {
                <span class="hljs-keyword">return</span> ux.filter(elements, filterVisible);
            }
            <span class="hljs-keyword">return</span> elements;
        }
        <span class="hljs-comment">/**
         * Filter for eq.
         * @param filterStr
         * @param elements
         * @returns {Array}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterEq</span><span class="hljs-params">(filterStr, elements)</span> {</span>
            <span class="hljs-keyword">var</span> index = filterStr.match(<span class="hljs-regexp">/\d+/</span>)[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">return</span> elements[index] ? [ elements[index] ] : [];
        }
        <span class="hljs-comment">/**
         * Detect if is an ng-* class from the selectors.
         * @param cls
         * @returns {boolean}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNgClass</span><span class="hljs-params">(cls)</span> {</span>
            <span class="hljs-keyword">return</span> !!(cls &amp;&amp; cls.substr(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) === <span class="hljs-string">"ng-"</span>);
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterClasses</span><span class="hljs-params">(cls)</span> {</span>
            <span class="hljs-keyword">var</span> isToBeFiltered = cls ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (!isToBeFiltered &amp;&amp; exp.options.gridFocusManager &amp;&amp; exp.options.gridFocusManager.filterClasses) {
                isToBeFiltered = exp.options.gridFocusManager.filterClasses.indexOf(cls) !== -<span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">if</span> (!isToBeFiltered) {
                isToBeFiltered = isNgClass(cls);
            }
            <span class="hljs-keyword">return</span> !isToBeFiltered;
        }
        <span class="hljs-comment">/**
         * Apply event listeners to the row.
         * @param rowElm
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addListenersToRow</span><span class="hljs-params">(rowElm)</span> {</span>
            <span class="hljs-keyword">var</span> focusable = getFocusableElements(rowElm);
            <span class="hljs-keyword">if</span> (focusable.length) {
                focusable = angular.element(focusable);
                focusable.bind(<span class="hljs-string">"keydown"</span>, onKeyDown);
            }
        }
        <span class="hljs-comment">/**
         * Remove event listeners from that row.
         * @param rowElm
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeListenersToRow</span><span class="hljs-params">(rowElm)</span> {</span>
            <span class="hljs-keyword">var</span> focusable = getFocusableElements(rowElm);
            <span class="hljs-keyword">if</span> (focusable.length) {
                focusable = angular.element(focusable);
                focusable.unbind(<span class="hljs-string">"keydown"</span>, onKeyDown);
            }
        }
        <span class="hljs-comment">/**
         * Handle Enter, up/down key events.
         * @param event
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onKeyDown</span><span class="hljs-params">(event)</span> {</span>
            <span class="hljs-keyword">var</span> target = angular.element(event.currentTarget);
            exp.flow.log(<span class="hljs-string">"FM: onKeyDown"</span>);
            <span class="hljs-keyword">if</span> (event.shiftKey &amp;&amp; event.keyCode === <span class="hljs-number">13</span> || event.keyCode === <span class="hljs-number">38</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>SHIFT+ENTER, UP ARROW</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                focusToPrevRowElement(target);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.keyCode === <span class="hljs-number">13</span> || event.keyCode === <span class="hljs-number">40</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>ENTER, DOWN ARROW</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                focusToNextRowElement(target);
            }
        }
        <span class="hljs-comment">/**
         * Focus to the previous row element from the current focused element.
         * @param focusedEl
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">focusToPrevRowElement</span><span class="hljs-params">(focusedEl)</span> {</span>
            <span class="hljs-keyword">var</span> focusEl = getPrevRowFocusElement(focusedEl, -<span class="hljs-number">1</span>);
            performFocus(focusEl);
        }
        <span class="hljs-comment">/**
         * Focus to the next row element from the current focused element.
         * @param focusedEl
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">focusToNextRowElement</span><span class="hljs-params">(focusedEl)</span> {</span>
            exp.flow.log(<span class="hljs-string">"	FM: focusToNextRowElement"</span>);
            <span class="hljs-keyword">var</span> focusEl = getNextRowFocusElement(focusedEl);
            performFocus(focusEl);
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasPrevRowFocusElement</span><span class="hljs-params">(focusedEl)</span> {</span>
            <span class="hljs-keyword">var</span> el = getPrevRowFocusElement(focusedEl);
            <span class="hljs-keyword">return</span> !!(el &amp;&amp; el.length);
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasNextRowFocusElement</span><span class="hljs-params">(focusedEl)</span> {</span>
            <span class="hljs-keyword">var</span> el = getNextRowFocusElement(focusedEl);
            <span class="hljs-keyword">return</span> !!(el &amp;&amp; el.length);
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPrevRowFocusElement</span><span class="hljs-params">(focusedEl)</span> {</span>
            <span class="hljs-keyword">return</span> focusToRowElement(focusedEl, -<span class="hljs-number">1</span>);
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextRowFocusElement</span><span class="hljs-params">(focusedEl)</span> {</span>
            exp.flow.log(<span class="hljs-string">"	FM: getNextRowFocusElement"</span>);
            <span class="hljs-keyword">return</span> focusToRowElement(focusedEl, <span class="hljs-number">1</span>);
        }
        <span class="hljs-comment">/**
         * Do the heavy lifting for focusing from one row to the next and pulling the selector.
         * Since it is the same going to previous or next it is all one method and just needs to know which direction
         * to increment.
         * @param focusedEl
         * @param dir
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">focusToRowElement</span><span class="hljs-params">(focusedEl, dir)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>dir should be 1 or -1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            exp.flow.log(<span class="hljs-string">"	FM: focusToRowElement"</span>);
            focusedEl = wrap(focusedEl);
            <span class="hljs-keyword">if</span> (!exp.element[<span class="hljs-number">0</span>].contains(focusedEl[<span class="hljs-number">0</span>])) {
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">var</span> resultEl, rowEl = getRowElmFromChildElm(focusedEl), currentIndex = exp.getRowIndexFromElement(focusedEl), nextIndex = currentIndex + dir, selector;
            <span class="hljs-keyword">if</span> (nextIndex &lt; <span class="hljs-number">0</span> || nextIndex &gt;= exp.rowsLength) {
                <span class="hljs-keyword">return</span> focusedEl;
            }
            selector = ux.selector.getSelector(focusedEl[<span class="hljs-number">0</span>], rowEl[<span class="hljs-number">0</span>], filterClasses);
            exp.flow.log(<span class="hljs-string">"	FM: selector: %s"</span>, selector);
            resultEl = findNextRowWithSelection(nextIndex, dir, selector);
            <span class="hljs-keyword">return</span> resultEl &amp;&amp; resultEl.length ? resultEl : focusedEl;
        }
        <span class="hljs-comment">/**
         * Do the actual focus. Select the text if select exists.
         * @param focusEl
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performFocus</span><span class="hljs-params">(focusEl)</span> {</span>
            exp.flow.log(<span class="hljs-string">"	FM: performFocus %o"</span>, focusEl[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">if</span> (focusEl[<span class="hljs-number">0</span>].select) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>TODO: if no jquery. There may be no select.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                focusEl[<span class="hljs-number">0</span>].select();
            }
            <span class="hljs-keyword">if</span> (focusEl[<span class="hljs-number">0</span>]) {
                focusEl[<span class="hljs-number">0</span>].focus();
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>we now need to scroll the row into view if it is not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            exp.scrollModel.scrollIntoView(exp.getRowIndexFromElement(focusEl), <span class="hljs-literal">true</span>);
        }
        <span class="hljs-comment">/**
         * Find the next row that has a matching selection. If one is not found it will no focus.
         * Since a creep render happens after every scroll it should not have difficulty finding a row.
         * However, possible bug here if a selector similar to this one doesn't exist for a large distance.
         * @param nextIndex
         * @param dir
         * @param selector
         * @returns {element|*}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNextRowWithSelection</span><span class="hljs-params">(nextIndex, dir, selector)</span> {</span>
            exp.flow.log(<span class="hljs-string">"	FM: findNextRowWithSelection"</span>);
            <span class="hljs-keyword">var</span> nextEl = exp.getRowElm(nextIndex), focusEl = query(nextEl[<span class="hljs-number">0</span>], selector);
            <span class="hljs-keyword">var</span> content = exp.getContent();
            <span class="hljs-keyword">while</span> (!focusEl[<span class="hljs-number">0</span>] &amp;&amp; (dir &gt; <span class="hljs-number">0</span> &amp;&amp; nextIndex &lt; exp.rowsLength - <span class="hljs-number">1</span> || dir &lt; <span class="hljs-number">0</span> &amp;&amp; nextIndex &gt; <span class="hljs-number">0</span>)) {
                nextIndex += dir;
                nextEl = exp.getRowElm(nextIndex);
                <span class="hljs-keyword">if</span> (nextEl[<span class="hljs-number">0</span>] === content) {
                    <span class="hljs-keyword">return</span>;
                }
                focusEl = query(nextEl[<span class="hljs-number">0</span>], selector);
            }
            <span class="hljs-keyword">return</span> focusEl;
        }
        result.hasPrevRowFocusElement = hasPrevRowFocusElement;
        result.hasNextRowFocusElement = hasNextRowFocusElement;
        result.focusToPrevRowElement = focusToPrevRowElement;
        result.focusToNextRowElement = focusToNextRowElement;
        result.query = query;
        result.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">while</span> (unwatchers.length) {
                unwatchers.pop()();
            }
            unwatchers = <span class="hljs-literal">null</span>;
            result = <span class="hljs-literal">null</span>;
        };
        unwatchers.push(exp.scope.$on(exports.datagrid.events.ON_BEFORE_UPDATE_WATCHERS, removeListeners));
        unwatchers.push(exp.scope.$on(exports.datagrid.events.ON_AFTER_UPDATE_WATCHERS, addListeners));
        unwatchers.push(exp.scope.$on(exports.datagrid.events.FOCUS_TO_PREV_ELEMENT_OF_SAME, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            focusToPrevRowElement(document.activeElement);
        }));
        unwatchers.push(exp.scope.$on(exports.datagrid.events.FOCUS_TO_NEXT_ELEMENT_OF_SAME, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            focusToNextRowElement(document.activeElement);
        }));
        exp.gridFocusManager = result;
        <span class="hljs-keyword">return</span> exp;
    };
});
}(<span class="hljs-keyword">this</span>.ux = <span class="hljs-keyword">this</span>.ux || {}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;}()));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
