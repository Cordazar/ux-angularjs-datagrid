{"version":3,"file":"ux-datagrid-iscroll.min.js","sources":["../../../../src/addons/touch/iScrollAddon.js"],"names":["angular","module","factory","inst","refresh","options","mouseWheel","scrollbars","bounce","bindToWrapper","tap","interactiveScrollbars","deceleration","click","startY","scrollHistory","getCurrentScroll","values","scroll","myScroll","element","style","overflowY","result","log","IScroll","on","beforeScrollStart","onScrollEnd","_initEvents","scroller","getContent","scrollerStyle","scrollTo","iScroll","refeshRender","clearRefreshRender","unwatchRefreshRender","setInterval","onRefreshRender","stop","clearTimeout","intv","scrolling","dispatch","exports","datagrid","events","ON_SCROLL_START","y","setTimeout","scrollEnd","updateDelay","originalScrollModel","onScrollingStop","clearInterval","h","offsetHeight","getContentHeight","onUpdateScroll","event","forceValue","value","undefined","lastY","speed","absSpeed","Math","abs","setScroll","scrollPercent","toFixed","fireOnScroll","isIOS","Error","scrollToIntv","unwatchSetup","logWrapper","scrollModel","scope","$on","ON_READY","removeScrollListener","unwatchers","push","ON_AFTER_HEIGHTS_UPDATED_RENDER","getScroll","waitForStop","immediately","scrollTop","capScrollValue","scrollToIndex","scrollToItem","scrollIntoView","scrollToBottom","getViewportHeight","destroy"],"mappings":"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","sourcesContent":["/**\n * ##<a name=\"iScrollAddon\">iScrollAddon</a>##\n * This requires [iscroll.js](https://github.com/cubiq/iscroll) to work.\n */\nangular.module('ux').factory('iScrollAddon', function () {\n    return ['inst', function (inst) {\n        // This is only needed for IOS devices. Android devices work fine without it.\n        if (!exports.datagrid.isIOS) {\n            return;\n        }\n        if (!IScroll) {\n            throw new Error(\"IScroll (https://github.com/cubiq/iscroll) is required to use the iScrollAddon.\");\n        }\n        var result = exports.logWrapper('iScrollAddon', {}, 'purple', inst.dispatch),\n            scrolling = false,\n            intv,\n            myScroll,\n            originalScrollModel = inst.scrollModel,\n            unwatchRefreshRender,\n            scrollToIntv,\n            unwatchSetup,\n            lastY = 0;\n\n        unwatchSetup = inst.scope.$on(exports.datagrid.events.ON_READY, function () {\n            originalScrollModel.removeScrollListener();\n            unwatchSetup();\n        });\n        inst.unwatchers.push(inst.scope.$on(exports.datagrid.events.ON_AFTER_HEIGHTS_UPDATED_RENDER, refresh));\n\n        function refresh() {\n            var options = {\n                mouseWheel: true,\n                scrollbars: true,\n                bounce: true,\n                bindToWrapper: true,\n                tap: true,\n                interactiveScrollbars: true,\n                deceleration: 0.005,\n                click: true,\n                startY: -(inst.scrollHistory && inst.scrollHistory.getCurrentScroll() || inst.values.scroll || 0)\n            };\n            if (!myScroll) {\n                inst.element[0].style.overflowY = 'hidden';\n                //TODO: these options need to be passed in.\n                result.log(\"IScroll Init at startY %s\", options.startY);\n                myScroll = new IScroll(inst.element[0], options);\n                myScroll.on('beforeScrollStart', beforeScrollStart);\n                myScroll.on('scrollStart', beforeScrollStart);\n                myScroll.on('scrollEnd', onScrollEnd);\n            }\n            myScroll._initEvents(true);\n            myScroll.scroller = inst.getContent()[0];\n            myScroll.scrollerStyle = myScroll.scroller.style;\n            myScroll._initEvents();\n            myScroll.scrollTo(0, options.startY);// update the transform.\n            result.iScroll = myScroll;\n            refeshRender();\n        }\n\n        function refeshRender() {\n            // iScroll always needs to wait till the next frame for offsetHeight to update before refresh.\n            clearRefreshRender();\n            unwatchRefreshRender = setInterval(onRefreshRender, 100);\n        }\n\n        function stop() {\n            clearTimeout(intv);\n        }\n\n        function beforeScrollStart() {\n            stop();\n            scrolling = true;\n            inst.dispatch(exports.datagrid.events.ON_SCROLL_START, -myScroll.y);\n        }\n\n        function onScrollEnd() {\n            stop();\n            intv = setTimeout(scrollEnd, inst.options.updateDelay);\n        }\n\n        function scrollEnd() {\n            inst.values.scroll = -myScroll.y;\n            originalScrollModel.onScrollingStop();\n            scrolling = false;\n        }\n\n        function clearRefreshRender() {\n            clearInterval(unwatchRefreshRender);\n        }\n\n        function onRefreshRender() {\n            var h;\n            if (!inst.element) {\n                clearRefreshRender();\n            } else if ((h = inst.element[0].offsetHeight)) {\n                clearRefreshRender();\n                result.log(\"\\trefresh iscroll height:%s/%s\", h, inst.getContentHeight());\n                myScroll.refresh();\n            }\n        }\n\n        function onUpdateScroll(event, forceValue) {\n            var value = forceValue !== undefined ? -forceValue : myScroll.y;\n            if (scrolling && value !== lastY) {\n                inst.values.speed = value - lastY;\n                inst.values.absSpeed = Math.abs(inst.values.speed);\n                result.setScroll(-value);\n                lastY = value;\n                inst.values.scrollPercent = ((inst.values.scroll / inst.getContentHeight()) * 100).toFixed(2);\n                result.fireOnScroll();\n            }\n        }\n\n        result.getScroll = function () {\n            return myScroll && myScroll.y || 0;\n        };\n        result.setScroll = function (value) {\n            result.log(\"setScroll %s\", value);\n            inst.values.scroll = value;\n        };\n        result.waitForStop = originalScrollModel.waitForStop;\n        result.scrollTo = function (value, immediately) {\n            result.log(\"scrollTo %s\", value);\n            if (inst.element[0].scrollTop) {\n                inst.element[0].scrollTop = 0;\n            }\n            if (!myScroll) {\n                refresh();\n            }\n            value = originalScrollModel.capScrollValue(value);\n            myScroll.scrollTo(0, -value, immediately ? 0 : 200);\n            clearTimeout(scrollToIntv);\n            if (immediately) {\n                if (inst.values.scroll || value) {\n                    scrolling = true;\n                    result.onUpdateScroll(null, value);\n                    scrolling = false;\n                    result.onScrollingStop();\n                }\n            } else {\n                scrollToIntv = setTimeout(function () {\n                    result.onScrollingStop();\n                }, 200);\n            }\n            // otherwise iscroll will cause the onScrollStop to fire.\n        };\n        result.scrollToIndex = originalScrollModel.scrollToIndex;\n        result.scrollToItem = originalScrollModel.scrollToItem;\n        result.scrollIntoView = originalScrollModel.scrollIntoView;\n        result.scrollToBottom = function (immediately) {\n            var value = inst.getContentHeight() - inst.getViewportHeight();\n            myScroll.scrollTo(0, -value, immediately ? 0 : 200);\n        };\n        result.onScrollingStop = originalScrollModel.onScrollingStop;\n        result.onUpdateScroll = onUpdateScroll;\n        result.fireOnScroll = originalScrollModel.fireOnScroll;\n        inst.unwatchers.push(inst.scope.$on(exports.datagrid.events.ON_AFTER_HEIGHTS_UPDATED_RENDER, function () {\n            inst.element[0].scrollTop = 0;\n            if (myScroll) {\n                onRefreshRender();\n            }\n        }));\n        result.destroy = function destroy() {\n            unwatchSetup();\n            clearTimeout(scrollToIntv);\n            stop();\n            originalScrollModel.destroy();\n            if (myScroll) {\n                myScroll.destroy();\n            }\n        };\n        inst.scrollModel = result;\n        return result;\n    }];\n});"]}